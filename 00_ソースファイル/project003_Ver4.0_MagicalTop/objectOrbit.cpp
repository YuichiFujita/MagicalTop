//============================================================
//
//	オブジェクト軌跡処理 [objectOrbit.cpp]
//	Author：藤田勇一
//
//============================================================
#if 1
//************************************************************
//	インクルードファイル
//************************************************************
#include "objectOrbit.h"
#include "manager.h"
#include "renderer.h"
#include "texture.h"

//************************************************************
//	マクロ定義
//************************************************************
#define MAX_OFFSET	(2)	// オフセットの数

//************************************************************
//	子クラス [CObjectOrbit] のメンバ関数
//************************************************************
//============================================================
//	コンストラクタ
//============================================================
CObjectOrbit::CObjectOrbit()
{
	// メンバ変数をクリア
	m_pVtxBuff = NULL;	// 頂点バッファ
	m_nNumVtx = 0;		// 必要頂点数
	m_nNumAround = 0;	// 渦の周回数
	m_nPattern = 0;		// 渦の分割数
	m_nTextureID = 0;	// テクスチャインデックス
	memset(&m_orbit, 0, sizeof(m_orbit));	// 軌跡の情報
}

//============================================================
//	オーバーロードコンストラクタ
//============================================================
CObjectOrbit::CObjectOrbit(const CObject::LABEL label, const int nPriority) : CObject(label, nPriority)
{
	// メンバ変数をクリア
	m_pVtxBuff = NULL;	// 頂点バッファ
	m_nNumVtx = 0;		// 必要頂点数
	m_nNumAround = 0;	// 渦の周回数
	m_nPattern = 0;		// 渦の分割数
	m_nTextureID = 0;	// テクスチャインデックス
	memset(&m_orbit, 0, sizeof(m_orbit));	// 軌跡の情報
}

//============================================================
//	デストラクタ
//============================================================
CObjectOrbit::~CObjectOrbit()
{

}

//============================================================
//	初期化処理
//============================================================
HRESULT CObjectOrbit::Init(void)
{
	// ポインタを宣言
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();	// デバイスのポインタ

	// メンバ変数を初期化
	m_pVtxBuff = NULL;	// 頂点バッファ
	m_nNumVtx = 0;		// 必要頂点数
	m_nNumAround = 0;	// 渦の周回数
	m_nPattern = 0;		// 渦の分割数
	m_nTextureID = NONE_IDX;	// テクスチャインデックス

	// 軌跡の情報を初期化
	m_orbit.pos     = VEC3_ZERO;		// 位置
	m_orbit.rot     = VEC3_ZERO;		// 向き
	m_orbit.direRot = VEC3_ZERO;		// 成長向き
	m_orbit.col     = XCOL_WHITE;		// 色
	m_orbit.pMtxParent  = NULL;		// 親のマトリックス
	m_orbit.fMoveRot    = 0.0f;		// 向きの変更量
	m_orbit.fThickness  = 0.0f;		// ポリゴンの太さ
	m_orbit.fOuterPlus  = 0.0f;		// ポリゴン外周の y座標加算量
	m_orbit.fSetWidth   = 0.0f;		// 生成時の横ずれ量
	m_orbit.fSetAlpha   = 0.0f;		// 生成時の透明度
	m_orbit.fAddWidth   = 0.0f;		// 横ずれの加算量
	m_orbit.fAddHeight  = 0.0f;		// 縦ずれの加算量
	m_orbit.fSubAlpha   = 0.0f;		// 透明度の減算量
	m_orbit.fGrowWidth  = 0.0f;		// 横ずれの成長量
	m_orbit.fGrowHeight = 0.0f;		// 縦ずれの成長量
	m_orbit.fGrowAlpha  = 0.0f;		// 透明度の成長量
	m_orbit.cull   = D3DCULL_NONE;	// カリング状況
	m_orbit.bLight = false;			// ライティング状況

	// 渦を設定
	if (FAILED(SetVortex(1, 1)))
	{ // 渦の設定に失敗した場合

		// 失敗を返す
		return E_FAIL;
	}

	// 成功を返す
	return S_OK;
}

//============================================================
//	終了処理
//============================================================
void CObjectOrbit::Uninit(void)
{
	// 頂点バッファの破棄
	if (USED(m_pVtxBuff))
	{ // 頂点バッファが使用中の場合

		// メモリ開放
		m_pVtxBuff->Release();
		m_pVtxBuff = NULL;
	}

	// オブジェクト軌跡を破棄
	Release();
}

//============================================================
//	更新処理
//============================================================
void CObjectOrbit::Update(void)
{
	// 軌跡の向きを変更
	m_orbit.rot.y -= m_orbit.fMoveRot;

	// 向きを正規化
	useful::NormalizeRot(m_orbit.rot.y);

	// 軌跡を成長させる
	m_orbit.fSetWidth  += m_orbit.fGrowWidth * m_nNumVtx;	// 原点からの横ずれ量を加算
	m_orbit.fAddWidth  += m_orbit.fGrowWidth;	// 軌跡の横の広がりを加算
	m_orbit.fAddHeight += m_orbit.fGrowHeight;	// 軌跡の縦の広がりを加算
	m_orbit.fSetAlpha  -= m_orbit.fGrowAlpha;	// 軌跡の透明度を減算 (透明にしていく)

	// 頂点情報の設定
	SetVtx();

	if (m_orbit.fSetAlpha <= 0.0f)
	{ // 軌跡が透明になった場合

		// 軌跡オブジェクトの終了
		Uninit();

		// 処理を抜ける
		return;
	}
}

//============================================================
//	描画処理
//============================================================
void CObjectOrbit::Draw(void)
{
	// 変数を宣言
	D3DXMATRIX mtxRot, mtxTrans;	// 計算用マトリックス
	D3DXMATRIX mtxOrigin;			// 発生源のマトリックス

	// ポインタを宣言
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();	// デバイスのポインタ
	CTexture *pTexture = CManager::GetTexture();						// テクスチャへのポインタ

	// ポリゴンの裏面のみを表示状態にする
	pDevice->SetRenderState(D3DRS_CULLMODE, m_orbit.cull);

	// ライティングを無効にする
	pDevice->SetRenderState(D3DRS_LIGHTING, m_orbit.bLight);

	// αテストを有効にする
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);		// αテストの有効 / 無効の設定
	pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);	// αテストの設定
	pDevice->SetRenderState(D3DRS_ALPHAREF, 0);					// αテストの参照値設定

	//--------------------------------------------------------
	//	発生源のマトリックスを求める
	//--------------------------------------------------------
	// 発生源のマトリックスの初期化
	D3DXMatrixIdentity(&mtxOrigin);

	// 向きを反映
	D3DXMatrixRotationYawPitchRoll(&mtxRot, m_orbit.direRot.y, m_orbit.direRot.x, m_orbit.direRot.z);
	D3DXMatrixMultiply(&mtxOrigin, &mtxOrigin, &mtxRot);	// 成長向き

	// 位置を反映
	D3DXMatrixTranslation(&mtxTrans, m_orbit.pos.x, m_orbit.pos.y, m_orbit.pos.z);
	D3DXMatrixMultiply(&mtxOrigin, &mtxOrigin, &mtxTrans);	// 発生位置

	//--------------------------------------------------------
	//	ワールドマトリックスを求める
	//--------------------------------------------------------
	// ワールドマトリックスの初期化
	D3DXMatrixIdentity(&m_orbit.mtxWorld);

	// 向きを反映
	D3DXMatrixRotationYawPitchRoll(&mtxRot, m_orbit.rot.y, m_orbit.rot.x, m_orbit.rot.z);
	D3DXMatrixMultiply(&m_orbit.mtxWorld, &m_orbit.mtxWorld, &mtxRot);	// 回転量

	//--------------------------------------------------------
	//	マトリックスを掛け合わせる
	//--------------------------------------------------------
	if (USED(m_orbit.pMtxParent))	// TODO：親マトリックスがNULLじゃなくなったときに判断できない
	{ // 親のマトリックスが存在する場合

		// 親のマトリックスと掛け合わせる
		D3DXMatrixMultiply(&mtxOrigin, &mtxOrigin, m_orbit.pMtxParent);
	}

	// 発生源のマトリックスと掛け合わせる
	D3DXMatrixMultiply(&m_orbit.mtxWorld, &m_orbit.mtxWorld, &mtxOrigin);

	//--------------------------------------------------------
	//	軌跡を描画
	//--------------------------------------------------------
	// ワールドマトリックスの設定
	pDevice->SetTransform(D3DTS_WORLD, &m_orbit.mtxWorld);

	// 頂点バッファをデータストリームに設定
	pDevice->SetStreamSource(0, m_pVtxBuff, 0, sizeof(VERTEX_3D));

	// 頂点フォーマットの設定
	pDevice->SetFVF(FVF_VERTEX_3D);

	// テクスチャの設定
	pDevice->SetTexture(0, pTexture->GetTexture(m_nTextureID));

	// ポリゴンの描画
	pDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, m_nNumVtx - 2);

	// ポリゴンの表面のみを表示状態にする
	pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);

	// ライティングを有効にする
	pDevice->SetRenderState(D3DRS_LIGHTING, true);

	// αテストを無効にする
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);		// αテストの有効 / 無効の設定
	pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);	// αテストの設定
	pDevice->SetRenderState(D3DRS_ALPHAREF, 0);					// αテストの参照値設定
}

//============================================================
//	生成処理
//============================================================
CObjectOrbit *CObjectOrbit::Create
(
	const D3DXVECTOR3& rPos,		// 位置
	const D3DXVECTOR3& rDireRot,	// 成長向き
	const D3DXCOLOR& rCol,			// 色
	D3DXMATRIX *pMtxParent,			// 親のマトリックス
	const int   nNumAround,			// 渦の周回数
	const int   nPattern,			// 渦の分割数
	const float fMoveRot,			// 向きの変更量
	const float fThickness,			// ポリゴンの太さ
	const float fOuterPlus,			// ポリゴン外周の y座標加算量
	const float fSetWidth,			// 生成時の横ずれ量
	const float fSetAlpha,			// 生成時の透明度
	const float fAddWidth,			// 横ずれの加算量
	const float fAddHeight,			// 縦ずれの加算量
	const float fSubAlpha,			// 透明度の減算量
	const float fGrowWidth,			// 横ずれの成長量
	const float fGrowHeight,		// 縦ずれの成長量
	const float fGrowAlpha,			// 透明度の成長量
	const D3DCULL cull,				// カリング状況
	const bool bLight				// ライティング状況
)
{
	// ポインタを宣言
	CObjectOrbit *pObjectOrbit = NULL;	// オブジェクト軌跡生成用

	if (UNUSED(pObjectOrbit))
	{ // 使用されていない場合

		// メモリ確保
		pObjectOrbit = new CObjectOrbit;	// オブジェクト軌跡
	}
	else { assert(false); return NULL; }	// 使用中

	if (USED(pObjectOrbit))
	{ // 確保に成功している場合

		// オブジェクト軌跡の初期化
		if (FAILED(pObjectOrbit->Init()))
		{ // 初期化に失敗した場合

			// メモリ開放
			delete pObjectOrbit;
			pObjectOrbit = NULL;

			// 失敗を返す
			return NULL;
		}

		// 位置を設定
		pObjectOrbit->SetPosition(rPos);

		// 向きを設定
		pObjectOrbit->SetDirectionRotation(rDireRot);

		// 色を設定
		pObjectOrbit->SetColor(rCol);

		// 親のマトリックスを設定
		pObjectOrbit->SetMatrixParent(pMtxParent);

		// ポリゴンの太さを設定
		pObjectOrbit->SetThickness(fThickness);

		// ポリゴン外周のy座標加算量を設定
		pObjectOrbit->SetOuterPlus(fOuterPlus);

		// 生成時の横ずれ量を設定
		pObjectOrbit->SetWidth(fSetWidth);

		// 生成時の透明度を設定
		pObjectOrbit->SetAlpha(fSetAlpha);

		// 横ずれの加算量を設定
		pObjectOrbit->SetAddWidth(fAddWidth);

		// 縦ずれの加算量を設定
		pObjectOrbit->SetAddHeight(fAddHeight);

		// 透明度の減算量を設定
		pObjectOrbit->SetSubAlpha(fSubAlpha);

		// カリングを設定
		pObjectOrbit->SetCulling(cull);

		// ライティングを設定
		pObjectOrbit->SetLighting(bLight);

		// 成長性を設定
		pObjectOrbit->SetGrow(fMoveRot, fGrowWidth, fGrowHeight, fGrowAlpha);

		// 渦を設定
		if (FAILED(pObjectOrbit->SetVortex(nNumAround, nPattern)))
		{ // 渦の設定に失敗した場合

			// メモリ開放
			delete pObjectOrbit;
			pObjectOrbit = NULL;

			// 失敗を返す
			return NULL;
		}

		// 確保したアドレスを返す
		return pObjectOrbit;
	}
	else { assert(false); return NULL; }	// 確保失敗
}

//============================================================
//	テクスチャ割当処理
//============================================================
void CObjectOrbit::BindTexture(const int nTextureID)
{
	// テクスチャインデックスを代入
	m_nTextureID = nTextureID;
}

//============================================================
//	位置の設定処理
//============================================================
void CObjectOrbit::SetPosition(const D3DXVECTOR3& rPos)
{
	// 引数の位置を設定
	m_orbit.pos = rPos;
}

//============================================================
//	成長向きの設定処理
//============================================================
void CObjectOrbit::SetDirectionRotation(const D3DXVECTOR3& rRot)
{
	// 引数の成長向きを設定
	m_orbit.direRot = rRot;

	// 成長向きの正規化
	useful::NormalizeRot(m_orbit.direRot.x);
	useful::NormalizeRot(m_orbit.direRot.y);
	useful::NormalizeRot(m_orbit.direRot.z);
}

//============================================================
//	色の設定処理
//============================================================
void CObjectOrbit::SetColor(const D3DXCOLOR& rCol)
{
	// 引数の色を設定
	m_orbit.col = rCol;

	// 頂点情報の設定
	SetVtx();
}

//============================================================
//	親のマトリックスの設定処理
//============================================================
void CObjectOrbit::SetMatrixParent(D3DXMATRIX *pMtxParent)
{
	// 引数の親マトリックスを設定
	m_orbit.pMtxParent = pMtxParent;
}

//============================================================
//	ポリゴンの太さの設定処理
//============================================================
void CObjectOrbit::SetThickness(const float fThickness)
{
	// 引数のポリゴンの太さを設定
	m_orbit.fThickness = fThickness;

	// 頂点情報の設定
	SetVtx();
}

//============================================================
//	ポリゴン外周のy座標加算量の設定処理
//============================================================
void CObjectOrbit::SetOuterPlus(const float fOuterPlus)
{
	// 引数のポリゴン外周のy座標加算量を設定
	m_orbit.fOuterPlus = fOuterPlus;

	// 頂点情報の設定
	SetVtx();
}

//============================================================
//	生成時の横ずれ量の設定処理
//============================================================
void CObjectOrbit::SetWidth(const float fSetWidth)
{
	// 引数の生成時の横ずれ量を設定
	m_orbit.fSetWidth = fSetWidth;

	// 頂点情報の設定
	SetVtx();
}

//============================================================
//	生成時の透明度の設定処理
//============================================================
void CObjectOrbit::SetAlpha(const float fSetAlpha)
{
	// 引数の生成時の透明度を設定
	m_orbit.fSetAlpha = fSetAlpha;

	// 頂点情報の設定
	SetVtx();
}

//============================================================
//	横ずれの加算量の設定処理
//============================================================
void CObjectOrbit::SetAddWidth(const float fAddWidth)
{
	// 引数の横ずれの加算量を設定
	m_orbit.fAddWidth = fAddWidth;

	// 頂点情報の設定
	SetVtx();
}

//============================================================
//	縦ずれの加算量の設定処理
//============================================================
void CObjectOrbit::SetAddHeight(const float fAddHeight)
{
	// 引数の縦ずれの加算量を設定
	m_orbit.fAddHeight = fAddHeight;

	// 頂点情報の設定
	SetVtx();
}

//============================================================
//	透明度の減算量の設定処理
//============================================================
void CObjectOrbit::SetSubAlpha(const float fSubAlpha)
{
	// 引数の透明度の減算量を設定
	m_orbit.fSubAlpha = fSubAlpha;

	// 頂点情報の設定
	SetVtx();
}

//============================================================
//	カリング設定処理
//============================================================
void CObjectOrbit::SetCulling(const D3DCULL cull)
{
	// 引数のカリング状況を設定
	m_orbit.cull = cull;
}

//============================================================
//	ライティング設定処理
//============================================================
void CObjectOrbit::SetLighting(const bool bLight)
{
	// 引数のライティング状況を設定
	m_orbit.bLight = bLight;
}

//============================================================
//	成長の設定処理
//============================================================
void CObjectOrbit::SetGrow(float fMoveRot, float fGrowWidth, float fGrowHeight, float fGrowAlpha)
{
	// 引数の情報を設定
	m_orbit.fMoveRot		= fMoveRot;		// 向きの変更量
	m_orbit.fGrowWidth	= fGrowWidth;	// 横ずれの成長量
	m_orbit.fGrowHeight	= fGrowHeight;	// 縦ずれの成長量
	m_orbit.fGrowAlpha	= fGrowAlpha;	// 透明度の成長量
}

//============================================================
//	渦の設定処理
//============================================================
HRESULT CObjectOrbit::SetVortex(const int nNumAround, const int nPattern)
{
	// ポインタを宣言
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();	// デバイスのポインタ

	// 引数の渦を設定
	m_nNumAround = nNumAround;
	m_nPattern = nPattern;

	// 必要頂点数を求める
	m_nNumVtx = m_nNumAround * m_nPattern * MAX_OFFSET;

	// 頂点バッファの破棄
	if (USED(m_pVtxBuff))
	{ // 頂点バッファが使用中の場合

		// メモリ開放
		m_pVtxBuff->Release();
		m_pVtxBuff = NULL;
	}

	// 頂点バッファの情報を設定
	if (UNUSED(m_pVtxBuff))
	{ // 非使用中の場合

		// 頂点バッファの生成
		if (FAILED(pDevice->CreateVertexBuffer
		( // 引数
			sizeof(VERTEX_3D) * m_nNumVtx,	// 必要頂点数
			D3DUSAGE_WRITEONLY,	// 使用方法
			FVF_VERTEX_3D,		// 頂点フォーマット
			D3DPOOL_MANAGED,	// メモリの指定
			&m_pVtxBuff,		// 頂点バッファへのポインタ
			NULL
		)))
		{ // 頂点バッファの生成に失敗した場合

			// 失敗を返す
			assert(false);
			return E_FAIL;
		}
	}
	else { assert(false); return E_FAIL; }	// 使用中

	// 頂点情報の設定
	SetVtx();

	// 成功を返す
	return S_OK;
}

//============================================================
//	位置取得処理
//============================================================
D3DXVECTOR3 CObjectOrbit::GetPosition(void) const
{
	// 位置を返す
	return m_orbit.pos;
}

//============================================================
//	成長向き取得処理
//============================================================
D3DXVECTOR3 CObjectOrbit::GetDirectionRotation(void) const
{
	// 成長向きを返す
	return m_orbit.direRot;
}

//============================================================
//	色取得処理
//============================================================
D3DXCOLOR CObjectOrbit::GetColor(void) const
{
	// 色を返す
	return m_orbit.col;
}

//============================================================
//	ポリゴンの太さ取得処理
//============================================================
float CObjectOrbit::GetThickness(void) const
{
	// ポリゴンの太さを返す
	return m_orbit.fThickness;
}

//============================================================
//	ポリゴン外周のy座標加算量の取得処理
//============================================================
float CObjectOrbit::GetOuterPlus(void) const
{
	// ポリゴン外周のy座標加算量を返す
	return m_orbit.fOuterPlus;
}

//============================================================
//	生成時の横ずれ量取得処理
//============================================================
float CObjectOrbit::GetWidth(void) const
{
	// 生成時の横ずれ量を返す
	return m_orbit.fSetWidth;
}

//============================================================
//	生成時の透明度取得処理
//============================================================
float CObjectOrbit::GetAlpha(void) const
{
	// 生成時の透明度を返す
	return m_orbit.fSetAlpha;
}

//============================================================
//	横ずれの加算量取得処理
//============================================================
float CObjectOrbit::GetAddWidth(void) const
{
	// 横ずれの加算量を返す
	return m_orbit.fAddWidth;
}

//============================================================
//	縦ずれの加算量取得処理
//============================================================
float CObjectOrbit::GetAddHeight(void) const
{
	// 縦ずれの加算量を返す
	return m_orbit.fAddHeight;
}

//============================================================
//	透明度の減算量取得処理
//============================================================
float CObjectOrbit::GetSubAlpha(void) const
{
	// 透明度の減算量を返す
	return m_orbit.fSubAlpha;
}

//============================================================
//	カリング取得処理
//============================================================
D3DCULL CObjectOrbit::GetCulling(void) const
{
	// カリング状況を返す
	return m_orbit.cull;
}

//============================================================
//	ライティング取得処理
//============================================================
bool CObjectOrbit::GetLighting(void) const
{
	// ライティング状況を返す
	return m_orbit.bLight;
}

//============================================================
//	頂点情報の設定処理
//============================================================
void CObjectOrbit::SetVtx(void)
{
	// 変数を宣言
	D3DXVECTOR3 vecPos;	// 軌跡の頂点方向ベクトル
	float fWidth  = m_orbit.fSetWidth;	// 頂点方向の横ずれ量
	float fHeight = 0.0f;					// 頂点方向の縦ずれ量
	float fAlpha  = m_orbit.fSetAlpha;	// 頂点カラーの透明度

	// ポインタを宣言
	VERTEX_3D *pVtx;	// 頂点情報へのポインタ

	if (USED(m_pVtxBuff))
	{ // 軌跡の頂点バッファが使用中の場合

		// 頂点バッファをロックし、頂点情報へのポインタを取得
		m_pVtxBuff->Lock(0, 0, (void**)&pVtx, 0);

		for (int nCntWidth = 0; nCntWidth < m_nNumAround; nCntWidth++)
		{ // 渦の周回の総数分繰り返す

			for (int nCntHeight = 0; nCntHeight < m_nPattern; nCntHeight++)
			{ // 渦の分割数分繰り返す

				// 頂点方向ベクトルを求める
				vecPos.x = sinf(nCntHeight * ((D3DX_PI * 2.0f) / m_nPattern)) * 1.0f;
				vecPos.y = 1.0f;
				vecPos.z = cosf(nCntHeight * ((D3DX_PI * 2.0f) / m_nPattern)) * 1.0f;

				for (int nCntSet = 0; nCntSet < MAX_OFFSET; nCntSet++)
				{ // オフセットの総数分繰り返す

					// 頂点座標の設定
					pVtx[0].pos.x = 0.0f + vecPos.x * (fWidth + (nCntSet * m_orbit.fThickness));	// x
					pVtx[0].pos.y = 0.0f + vecPos.y * (fHeight + (nCntSet * m_orbit.fOuterPlus));	// y
					pVtx[0].pos.z = 0.0f + vecPos.z * (fWidth + (nCntSet * m_orbit.fThickness));	// z

					// 法線ベクトルの設定
					pVtx[0].nor = VEC3_ZERO;

					if (fAlpha < 0.0f)
					{ // 透明度が範囲外の場合

						// 透明度を補正
						fAlpha = 0.0f;
					}

					// 頂点カラーの設定
					pVtx[0].col = D3DXCOLOR(m_orbit.col.r, m_orbit.col.g, m_orbit.col.b, fAlpha);

					// テクスチャ座標の設定
					pVtx[0].tex = D3DXVECTOR2
					( // 引数
						1.0f,			// u
						1.0f * nCntSet	// v
					);

					// 頂点データのポインタを進める
					pVtx += 1;
				}

				// 縦横を広げる
				fWidth  += m_orbit.fAddWidth;
				fHeight += m_orbit.fAddHeight;

				// α値を減算
				fAlpha -= m_orbit.fSubAlpha;
			}
		}

		// 頂点バッファをアンロックする
		m_pVtxBuff->Unlock();
	}
	else { assert(false); }	// 非使用中
}

#endif
